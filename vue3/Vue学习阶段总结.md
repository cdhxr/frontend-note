
Vue的想法是，将前端代码模块化，便于分文件编写，使代码逻辑更清晰
将页面的一部分，称为一个组件（如一个菜单，一个滑块）
.vue文件，就是一个组件，有HTML，CSS，JS/TS 代码组成，
将有特定功能的代码段，抽象了出来

# 一个组件由什么构成

可以像类一样，有属性和方法
也可以在里面直接实例化对象或者定义变量，称之为数据
事件，常常是方法的调用（自定义），或者像click之类的内置事件
还有**生命周期钩子**、**侦听器**、**插槽**等部分构成
这些部分结合在一起，定义了组件的行为、外观和与外界的交互方式。

# Vue的特殊功能，主要体现在，vue文件内的script标签内部

内置方法的导入：`import { 方法 } from vue
根据按需导入的原则，只将用到方法写在花括号内

## 响应式变量的定义

由于界面交互需要用到响应式变量
响应式变量的创建：ref方法和reactive方法

前者写法更简洁，后者更为底层

## 生命周期钩子

组件在页面渲染流程是固定的，所以会出现需要限制在某个时机执行的函数，
就引入了生命周期钩子的概念
钩子的引入方法和ref等等完全一样
就是一种特殊的自定义函数

## 监听

在应用中会遇到许多事件带来的，数据变化，想要捕获这些数据则要进行监听

**监听**（Watching）是指在数据发生变化时执行特定操作的过程。

利用`watch`方法，实现功能（类似于生命周期钩子也是一种特殊的自定义函数）

`watch(obj, (newVal, oldVal) =>({})`
obj可以是数组，以传入多个事件
有immediate和deep的类似于属性的语法调整其效果

# 随着组件数量的上升必然涉及组件间的嵌套，通信
## ref属性的用法

1. 父组件调用子组件中的属性和方法

	- 对象在子组件标签中用ref属性声明，则其将被识别为子组件对象
	- 由于vue3默认属性和方法封闭，需要在子组件中，用defineExpose暴露方法和属性

2. 获取DOM元素或者组件实例

	- 在目标获得的标签中定义ref属性
	- 利用`ref('null')`创建同名对象
	- 在渲染后即可用，对象名.value得到
 
## 父组件使用子组件

1. 导入from文件路径
2. 在template中`<组件名>`当做标签，直接使用即可

## 父组件向子组件传递

父组件中在 子组件标签 中使用v-bind语法，传值
子组件中使用defineProps语法接收

## 子组件向父组件传递

场景：子组件中有一个事件，事件被触发时，父组件需要子组件的数据来触发一个方法

逻辑：父组件中，监听事件，得到值，触发方法 

子组件中：
通过 `defineEmits` 声明子组件会触发的事件A，
还需要定义一个传值方法，
在子组件事件A被触发后，一定会调用该方法
传值方法会调用emit方法来实现，`emit( 事件名 , 事件值 )`

父组件中：
定义了一个利用事件值的目标方法
在子组件的标签内，通过事件绑定语法，`@事件A="目标方法"`
表示父组件监听事件A，事件被触发时会应用目标方法
##  跨层传递

利用provide方法和inject方法

