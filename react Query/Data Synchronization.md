
React Query 是如何处理这一复杂性的呢？从高层次来看，它的目标很简单：尽可能让屏幕上显示的数据与服务器的最新状态保持同步。
某种程度上，可以认为react Query是数据同步工具

以 Bug 追踪 Web 应用为例

例如，你在早晨打开应用，专注工作了几个小时后再次回来查看，此时客户端的状态和服务器的状态匹配的可能性几乎为零。

我们需要确定**缓存何时应该失效**，即缓存何时需要与服务器状态重新同步。
### `staleTime`：控制数据的新鲜度

在 React Query 中，**stale（过时）是 fresh（新鲜）的反义词**。只要查询（query）被认为是新鲜的，数据就会直接从缓存中提供。而 `staleTime`（过期时间）定义了数据在多长时间内被视为新鲜。

例如，如果我们将 `staleTime` 设为 **60 秒**，那么在此时间内，`queryFn` **不会被重新执行**。

React Query **默认的 `staleTime` 是 0 毫秒**！
也就是说，**所有查询数据都会被立即视为过时**。
其实，这个问题**没有通用答案**，因为它取决于具体的资源：
### `staleTime` 应该设置多少？

其实，这个问题**没有通用答案**，因为它取决于具体的资源：
例如：
- 如果你请求的是**一条推文的点赞数和评论数**，它可能很快就会过时，因此 `staleTime` 应该设得较短。
- 如果你请求的是**每日更新的汇率**，即使不立即重新获取，数据在一段时间内依然是准确的。

```js
useQuery({
  queryKey: ['repos', { sort }],
  queryFn: () => fetchRepos(sort),
  staleTime: 5 * 1000 // 5,000 ms or 5 seconds
})
```

- **当 `isStale` 为 `false`（即数据仍然是新鲜的）时**
    
    - 组件直接从缓存中获取数据。
    - **不会触发额外的请求**，即使组件重新渲染。
    
- **当 `isStale` 为 `true`（即数据已过时）时**
    
    - 组件仍然会**先使用缓存数据**，以保证界面有可用的数据。
    - **React Query 会在后台自动触发数据刷新**，获取最新数据并更新缓存。
    - 当新的数据返回后，React Query 会重新渲染组件，以显示最新的数据。

什么时候会触发数据刷新？

- **组件重新挂载**（例如用户切换页面后又返回）。
- **用户重新聚焦到页面**（从其他标签页切回来时）。
- **用户重新连接网络**（断网后恢复时）。
- **手动调用 `refetch`**（开发者手动触发数据刷新）。

Stale-While-Revalidate 策略

核心原则是：  
✅ **过时的数据总比没有数据好**。

### **React Query 何时会重新获取数据并更新缓存？**

前面我们提到 React Query 会**在合适的时机**触发数据重新获取（refetch）。具体来说，有**四种情况（触发器)** 会触发 refetch：

#### **1. `queryKey` 发生变化**

- `queryKey` 是 `useQuery` 的唯一标识。
- 当 `queryKey` 发生变化时（例如用户修改了排序方式、筛选条件等），如果查询是 stale（过时的），React Query 会自动重新获取数据并更新缓存。

#### **2. 一个新的组件挂载（新的 observer）**

- 通过 `useQuery` 创建的查询**会被视为 observer**（观察者）。
- 当一个新的组件挂载（比如用户打开了一个弹窗，或者切换到了新的页面），如果查询是 stale（过时的），React Query 会自动重新获取数据并更新缓存。

#### **3. 浏览器窗口重新获得焦点**

- React Query 默认会监听 `window focus` 事件。
- 当用户切换回该页面时，如果查询是 stale（过时的），React Query 会自动重新获取数据并更新缓存。
- 这对于**长期运行的 Web 应用**（如管理后台、数据仪表盘等）非常有用。

#### **4. 设备重新联网**

- 当设备离线后重新联网（例如用户进入地铁、隧道后恢复网络），如果查询是 stale（过时的），React Query 会自动重新获取数据并更新缓存。
- 这对移动端用户体验特别重要。

### **更好的方案：调整 `staleTime`**

如果只是希望**减少请求频率，而不是完全禁用**，更推荐的方式是**增加 `staleTime`**，让数据在更长时间内保持“新鲜”：

```tsx
useQuery({
  queryKey: ['repos', { sort }],
  queryFn: () => fetchRepos(sort),
  staleTime: 60000, // 60 秒内不会被标记为 stale，不会触发后台重新获取
});
```

如果你**完全确定数据不会变化**，甚至可以**让缓存数据永不过期**，设置 `staleTime` 为 `Infinity`：

```tsx
useQuery({
  queryKey: ['repos', { sort }],
  queryFn: () => fetchRepos(sort),
  staleTime: Infinity, // 永远不会标记为 stale，不会触发后台重新获取
});
```

---

### **⚠️ 重要提醒：`staleTime` 影响的是后台更新，不影响数据的交付方式！**

无论 `staleTime` 设定如何，React Query **始终会优先从缓存中返回数据**（只要缓存里有数据）。  
`staleTime` 只是决定**当触发器发生时，React Query 是否需要后台更新数据**。

---

### **🚀 核心总结**

✅ **React Query 总是优先返回缓存数据**，无论它是否新鲜。  
✅ **默认情况下，所有查询都是立即变为 stale**（`staleTime: 0`），所以触发器发生时会重新获取数据。  
✅ **如果查询是 stale**，React Query 会在触发器（`queryKey` 变化、组件挂载、窗口聚焦、网络恢复）发生时**后台更新缓存**。  
✅ **你可以禁用触发器**，但更推荐的做法是**合理设置 `staleTime`**，让资源在更长时间内保持新鲜。

这样，你就可以更灵活地控制数据获取的时机，优化用户体验，同时减少不必要的网络请求 🚀！