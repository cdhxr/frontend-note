
React Router 中有三种渲染策略：

- Client Side Rendering  客户端渲染
- Server Side Rendering  服务器端渲染
- Static Pre-rendering  静态预渲染

关键在于对react-router.config.ts的设置

通过ssr属性的true or false可以对设置全局的渲染策为CSR或者SSR

```ts
import type { Config } from "@react-router/dev/config";

export default {
  ssr: false,
} satisfies Config;

```


静态预渲染设置：

```ts
import type { Config } from "@react-router/dev/config";

export default {
  // return a list of URLs to prerender at build time
  async prerender() {
    return ["/", "/about", "/contact"];
  },
} satisfies Config;

```

预渲染是一种构建时操作，
它为一系列 URL 生成静态 HTML 和客户端导航数据有效载荷。

这对于 SEO 和性能非常有用，特别是对于没有服务器渲染的部署。
在预渲染时，会使用路由模块加载器在构建时获取数据。

# Prerender

**预渲染（Pre-rendering）** 是在构建时生成页面，**CSR（客户端渲染）** 是在浏览器中动态构建页面。

仅仅在构建时会在服务端执行所有Loader，Action本质还是和CSR行为一样

| 对比项        | Pre-rendering    | CSR                 |
| ---------- | ---------------- | ------------------- |
| 执行时机       | 构建阶段（打包时）        | 用户访问页面时             |
| 渲染位置       | 服务器/构建机器         | 浏览器中                |
| 是否先看到 HTML | ✅ 是（加载即显示）       | ❌ 否（要等 JS 加载 + 执行完） |
| 页面内容是否动态   | ❌ 固定（需要重新 build） | ✅ 可变（随请求变化）         |

| 场景         | Pre-rendering    | CSR                      |
| ---------- | ---------------- | ------------------------ |
| 首次加载速度     | 🚀 快（直接拿到 HTML）  | 🐢 慢（需要加载 JS 和 fetch 数据） |
| SEO        | ✅ 友好（HTML 可读）    | ❌ 差（需要 JS 执行才能有内容）       |
| 支持静态缓存/CDN | ✅ 可以             | ❌ 不行                     |
| 页面内容是否动态   | ❌ 固定（需要重新 build） | ✅ 可变（随请求变化）              |

# CSR

CSR模式下，Loader和Action都会在浏览器执行，那么其作用类似于react query

是否使用关键需要考虑未来有没有可能迁移SSR

| 项目规模                | 建议                                                   |
| ------------------- | ---------------------------------------------------- |
| 小项目、纯 CSR、不考虑 SSR   | ✅ 使用 React Query 更轻量灵活                               |
| 中大型项目、未来考虑 SSR 或预渲染 | 🔁 用 `loader/action` 替代页面级 fetch；React Query 用于组件内异步 |
| 已用 React Query，不想全改 | ✅ 保留 React Query，只在特殊场景使用 loader/action              |

# SSR

`loader` 和 `action` 都在服务端运行

好的，帮你详细对比一下 **SSR（服务端渲染）** 与 **有 API 层的 CSR（客户端渲染）** 这两种架构模式，从多个角度说明它们的差异、优缺点和适用场景。

---

# 1. 基本概念对比

|特性|SSR（服务端渲染）|有 API 层的 CSR（客户端渲染）|
|---|---|---|
|页面渲染位置|服务器端（每次请求服务器返回完整 HTML）|浏览器端（首次加载后由 JS 生成 DOM）|
|数据获取|服务端 loader 直接获取数据|前端通过 API 请求数据|
|HTML 返回|返回完整 HTML，含数据内容|返回基本空白 HTML，后由 JS 加载数据渲染页面|

---

# 2. 数据流和交互流程

|步骤|SSR|CSR + API|
|---|---|---|
|用户访问页面|发送请求 → 服务器执行 loader → 渲染页面|发送请求 → 服务器返回空白 shell → 前端请求 API 获取数据|
|页面首屏内容展示|服务器生成完整 HTML，快速显示内容|首次显示 Loading，等待数据加载|
|数据更新（如表单提交）|action 在服务器执行，返回新的页面或重定向|前端调用 API 接口，更新状态，重新渲染 UI|

---

# 3. 优缺点对比

| 方面     | SSR                      | CSR + API                 |
| ------ | ------------------------ | ------------------------- |
| 首屏加载速度 | 快（直接加载完整 HTML）           | 慢（先加载 JS 再请求数据）           |
| SEO    | 好，搜索引擎能直接抓取页面内容          | 差，页面内容需 JS 执行后才能获取        |
| 用户体验   | 立刻可见内容，交互顺畅              | 首屏加载时可能看到空白或加载动画          |
| 开发复杂度  | 需要服务端环境，loader/action 设计 | 前后端分离，API 设计，前端管理数据状态复杂度高 |
| 部署要求   | 需要支持服务器渲染环境（Node.js 等）   | 静态服务器即可，API 可独立部署         |
| 数据安全   | 数据请求在服务端，安全性更好           | API 接口需额外设计权限和安全保护        |
| 缓存和性能  | 可利用服务端缓存，减少重复渲染          | API 响应可独立缓存，但首屏依赖客户端处理    |

---

# 4. 代码设计差异

### SSR 示例（React Router v7）

```ts
export async function loader({ params }) {
  return fetchFromDB(params.id); // 直接访问数据库或后端资源
}

export async function action({ request }) {
  const form = await request.formData();
  await saveToDB(form);
  return redirect(`/profile/${form.get("id")}`);
}
```

- loader 和 action 在服务器执行，返回完整页面
    

---

### CSR + API 示例（React Query + REST API）

```ts
// 前端 React 组件
const { data, isLoading } = useQuery(['profile', userId], () =>
  fetch(`/api/profile/${userId}`).then(res => res.json())
);

const mutation = useMutation(formData => fetch('/api/profile', {
  method: 'POST',
  body: formData,
}));
```

- 前端请求 API，渲染和交互都在浏览器中完成
    

---

# 5. 适用场景建议

| 场景            | 推荐使用 SSR      | 推荐使用 CSR + API    |
| ------------- | ------------- | ----------------- |
| SEO 要求高的内容型网站 | 博客、文档、产品展示页   | 内部系统、用户仪表盘、后台管理   |
| 首屏性能要求        | 快速呈现完整页面      | 交互密集型应用，内容高度动态    |
| 团队结构          | 前后端合一，方便服务端协作 | 前后端分离，API 独立，便于扩展 |
| 复杂数据权限管理      | 服务器统一控制，安全    | 需要复杂前端状态管理和权限校验   |
|               |               |                   |

---

# 6. 总结

|维度|SSR|CSR + API|
|---|---|---|
|**加载体验**|首屏快，直接可见内容|首屏慢，先加载 JS 再取数据|
|**SEO 友好**|极佳|较差，需要额外方案改善|
|**开发复杂度**|需要服务器端配置|需要 API 设计和状态管理|
|**部署复杂度**|需要运行时服务器|静态资源 + API 服务|
|**安全性**|高，服务端直接控制|API 需额外安全措施|

---

如果你需要，我还可以帮你写一个简单的 SSR 和 CSR+API 的 Demo 示例代码，或者帮你分析你具体项目的技术选型，想了解吗？

# 混合渲染方案

