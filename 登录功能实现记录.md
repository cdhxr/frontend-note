
登录机制：
- 在服务器上用户被验证后，即用户发送了有效的凭据对
- 在后端（服务器），创建一个，但不存储，“准许” token (算法创建的字符串，存储着一些信息)，发送它到前端（客户端）
- 这个token的有效性只能由创建它的后端验证，因为token是使用后端的私钥创建的，这个私钥只有后端知道
- 在未来的请求中，从客户端到后端，我们将该请求附加至这些请求中
- 并且后端能够查看那个token，验证它是否是由后端先前设置的那个token

- 前端发送request到后端，后端返回response给前端，response包含那个token
- 前端需要存储token，并加入到future request
- 用该token作为标准判断是否user被锁定


注意点：
- 刷新登录状态不会掉

接口：

- 获取用户信息GET:   /capi/user/info
- 用户登录POST:       /capi/user/public/login
- 用户注册POST:       /capi/user/public/register

- 用户接口名
	- ![[Pasted image 20250402105424.png]]

触发了某个事件（点击了某个按钮，链接，跳转至某个界面......）

=>转入登录page or 跳出了登录弹窗（return 登录组件tsx）

登录组件状态与用户状态：

| 用户状态 | 触发条件            | 典型 UI 表现                       |     |
| ---- | --------------- | ------------------------------ | --- |
| 未登录  | 初始状态 / Token 无效 | 需要显示 **登录表单** 或 **OAuth 登录按钮** |     |
| 登录中  | 用户提交凭据          | 显示 "登录中…"                      |     |
| 登录成功 | 认证成功，JWT 存储     | 显示用户主页                         |     |
| 登录失败 | 密码错误 / OAuth 失败 | 显示错误消息                         |     |
| 登录过期 | JWT 失效          | 重新登录或刷新 Token                  |     |
| 已登出  | 用户主动退出          | 回到登录页                          |     |
|      |                 |                                |     |

开发逻辑：
- 注册
	- 接口逻辑：
		- 请求参数：
			- username：设置的用户名
			- password：设置的密码
		- 响应参数：
			- success：用于判断请求成功与否
			- errCode：错误码，用于辨别错误类型
			- errMsg：错误消息，用于提示用户
			- data：返回的userID
- 登录
	- 接口逻辑：
		- 请求参数：
			- userID：用户的唯一标识符
			- password：输入的密码
		- 响应参数：
			- success：用于判断请求成功与否
			- errCode：错误码
			- errMsg：错误消息，用于提示用户
			- data：返回的 **token**

基于localStorage的登录整体思路：

- 注册，POST请求，发送用户输入的用户名密码，将其存入后端，然后后端产生唯一的用户ID
- 登录，POST请求，发送用户输入的用户ID和密码，后端会进行校验，请求成功则返回token（data字段），这时setlocalStorage，将token存入localStorage
- 后续其他请求在请求头中可以在localStorage中取出token，发送请求时将token作为参数传递，后端能够查看那个token，验证它是否是由后端先前设置的那个token
- 退出登录，清除localStorage即可
- 登录状态保留：

UI逻辑细节：
- 