
# 原始版本


```js
//一次性获取所有角色
const roleQuery = useGetUserRolesQuery(userId ?? -1);

// 初始化角色数据
useEffect(() => {
  if (roleQuery.isSuccess) {
    initializeRoles();
  }
}, [roleQuery.isSuccess]);


// 列表渲染
filteredRoles.map(role => (
    <RoleListItem
	    key={role.id}
        role={role}
        isSelected={selectedRoleId === role.id}
        onSelect={() => {
	        setSelectedRoleId(role.id);
            setIsEditing(false);
            const drawerCheckbox = 
            document.getElementById("character-drawer") as HTMLInputElement;
			if (drawerCheckbox)
				drawerCheckbox.checked = false;
			}}
        onDelete={() => handleDelete(role.id)}
    />
  ))
)}
```








# 改进方案

你目前的逻辑中，每次分页数据更新（如加载下一页）时，**会重新 setRoles（覆盖旧值）并对所有角色重新加载头像**，即使这些头像早就加载过。这会造成 **重复请求头像**，效率低下。

---

### ✅ 改进目标：

1. **避免重复 setRoles（覆盖已存在的角色）**。
    
2. **避免重复加载头像（即已加载过的角色不要再请求头像）**。
    

---

### ✅ 改进思路：

#### ① 用 `Map` 缓存已加载的头像角色 ID

你可以在组件中维护一个状态或 `Set<number>`，存储已经加载过头像的角色 ID：

```tsx
const [loadedAvatarIds, setLoadedAvatarIds] = useState<Set<number>>(new Set());
```

---

#### ② 合并角色数据而不是直接 set（防止覆盖旧角色）

```tsx
setRoles(prev => {
  const existingIds = new Set(prev.map(r => r.id));
  const newRoles = mappedRoles.filter(r => !existingIds.has(r.id));
  return [...prev, ...newRoles];
});
```

---

#### ③ 加载头像时跳过已经加载过的角色：

```tsx
for (const role of mappedRoles) {
  if (loadedAvatarIds.has(role.avatarId)) continue;

  try {
    const res = await tuanchat.avatarController.getRoleAvatar(role.avatarId);
    if (res.success && res.data) {
      const avatarUrl = res.data.avatarUrl;
      queryClient.setQueryData(["roleAvatar", role.id], avatarUrl);

      setRoles(prevChars =>
        prevChars.map(char =>
          char.id === role.id ? { ...char, avatar: avatarUrl } : char
        )
      );

      // 记录这个头像ID已加载
      setLoadedAvatarIds(prev => new Set(prev).add(role.avatarId));
    }
  } catch (error) {
    console.error(`加载角色 ${role.id} 的头像时出错`, error);
  }
}
```

---

### ✅ 整体小结代码片段（简化合并版）：

```tsx
const [roles, setRoles] = useState<Role[]>([]);
const [loadedAvatarIds, setLoadedAvatarIds] = useState<Set<number>>(new Set());

...

if (isSuccess && roleQuery.pages.length > 0) {
  const mappedRoles = roleQuery.pages.flatMap(page =>
    (page.data?.list ?? []).map(convertRole)
  ) ?? [];

  // 合并新角色到 state（避免重复）
  setRoles(prev => {
    const existingIds = new Set(prev.map(r => r.id));
    const newRoles = mappedRoles.filter(r => !existingIds.has(r.id));
    return [...prev, ...newRoles];
  });

  // 加载新角色的头像（避免重复请求）
  for (const role of mappedRoles) {
    if (loadedAvatarIds.has(role.avatarId)) continue;

    try {
      const res = await tuanchat.avatarController.getRoleAvatar(role.avatarId);
      if (res.success && res.data) {
        const avatarUrl = res.data.avatarUrl;

        queryClient.setQueryData(["roleAvatar", role.id], avatarUrl);

        setRoles(prevChars =>
          prevChars.map(char =>
            char.id === role.id ? { ...char, avatar: avatarUrl } : char
          )
        );

        setLoadedAvatarIds(prev => new Set(prev).add(role.avatarId));
      }
    } catch (error) {
      console.error(`加载角色 ${role.id} 的头像时出错`, error);
    }
  }
}
```

---

### ✅ Bonus：也可以缓存 `avatarUrl`，避免重复 setQueryData

你可以用 `queryClient.getQueryData(...)` 判断是否已有头像缓存，也能避免不必要的请求。

需要我帮你用这个方式重构成一个更完整的自定义 hook 吗？

