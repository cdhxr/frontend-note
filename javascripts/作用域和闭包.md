---
tags:
  - js
---

## [词法环境](https://zh.javascript.info/closure#ci-fa-huan-jing)

在 JavaScript 中，每个运行的函数，代码块 `{...}` 以及整个脚本，
都有一个被称为 **词法环境（Lexical Environment）** 的内部（隐藏）的关联对象。

## 变量

变量的本质是，词法环境对象的属性

词法环境对象

- 环境记录对象
	- 存储了所有局部变量作为其属性
- 外部词法环境的引用

![[Pasted image 20250219152725.png]]

如图变量的值就是该属性的值，变量是一个环境的属性

这就是所谓的与整个脚本相关联的 **全局** 词法环境。
在上面的图片中，矩形表示环境记录（变量存储），箭头表示外部引用。全局词法环境没有外部引用，所以箭头指向了 `null`。

![[Pasted image 20250219153045.png]]

右侧的矩形演示了执行过程中全局词法环境的变化：

1. 当脚本开始运行，词法环境预先填充了所有声明的变量。
    - 最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 `let` 声明前，不能引用它。几乎就像变量不存在一样。
2. 然后 `let phrase` 定义出现了。它尚未被赋值，因此它的值为 `undefined`。从这一刻起，我们就可以使用变量了。
3. `phrase` 被赋予了一个值。
4. `phrase` 的值被修改。

类似于java会有complie的过程，js也会先过一边代码，再执行代码

## 函数声明

一个函数其实也是一个值，就像变量一样。
**不同之处在于函数声明的初始化会被立即完成。**

当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 `let` 那样直到声明处才可用）。

这就是为什么我们甚至可以在声明自身之前调用一个以函数声明（Function Declaration）的方式声明的函数。

例如，这是添加一个函数时全局词法环境的初始状态：

![[Pasted image 20250219154245.png]]

正常来说，这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 `let say = function(name)...`。

## 内部和外部的语法环境

在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。

例如，对于 `say("John")`，它看起来像这样（当前执行位置在箭头标记的那一行上）：

![[Pasted image 20250219155621.png]]

内部词法环境引用了 `outer`。

**当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。**

如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）

## 返回函数

![[Pasted image 20250219162007.png]]
所有函数都有名为 `[[Environment]]` 的隐藏属性
该属性保存了对创建该函数的词法环境的引用

编译时
首先创建词法环境对象，
定义属性，（let声明的变量:undefined，函数声明的属性:function）
如果不是全局词法环境对象（即函数内词法环境）
会创建environment属性指向外部环境对象，进而实现对外部环境属性的通信，以向外部属性通信

在刚才的解释中，我们提到了 **词法环境** 和 **[[异步编程]]** 属性。**闭包（Closure）** 就是基于这两个概念的一种现象。

### **闭包的定义**

**闭包是一个函数，是指一个函数可以记住其外部变量并可以访问这些变量。**

换句话说，当一个函数“记住”它创建时的环境，并且能够在后续的执行中继续访问这个环境中的变量时，这个函数就形成了一个**闭包**。

---

### **闭包的核心特点**

1. **函数嵌套（Inner Function）**
    - 只有当一个函数内部返回了另一个函数，闭包才会出现。
2. **外部变量不会被销毁**
    - 当外部函数执行完毕后，通常它的变量应该被销毁。但如果有内部函数依然在使用这些变量，它们就会一直存活在内存中。
3. **内部函数可以修改外部变量**
    - 返回的函数可以访问并修改外部函数的变量，即使外部函数已经执行完毕。


